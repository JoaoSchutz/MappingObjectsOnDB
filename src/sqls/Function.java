package sqls;

public class Function {

	public static final String function = "CREATE OR replace FUNCTION mapping_tool(varchar) RETURNS void AS\n"
			+ "$$\n"
			+ "begin\n"
			+ "	\n"
			+ "-- Creates the schema and the tables that will store the mapping\n"
			+ "\n"
			+ "create schema if not exists mapping_tool;\n"
			+ "create table if not exists mapping_tool.(KEYWORD) (tabela varchar, coluna varchar, select_atualizado varchar, fks_da_tabela varchar);\n"
			+ "create table if not exists mapping_tool.(KEYWORD2) (tabela varchar, coluna varchar, select_atualizado varchar, fks_da_tabela varchar);\n"
			+ "create table if not exists mapping_tool.(KEYWORD3) (tabela varchar, coluna varchar, select_atualizado varchar, fks_da_tabela varchar);\n"
			+ "create table if not exists mapping_tool.ddl (ddl varchar);\n"
			+ "\n"
			+ "-- generate mapping for keywork --\n"
			+ "\n"
			+ "insert into mapeamento.coaf (tabela, coluna , select_atualizado, fks_da_tabela)\n"
			+ "select distinct\n"
			+ "               t.table_name as tabela\n"
			+ "              ,string_agg(c.column_name, Chr(13)) as coluna\n"
			+ "              ,max(concat('SELECT * FROM '||$1||'.'||t.table_name||' ORDER BY 1 DESC')) as select_atualizado\n"
			+ "              ,string_agg(concat('LEFT JOIN '||k2.column_name|| ' ON ' || k2.column_name|| ' = ' ||'id'), Chr(13) ) as fks_da_tabela\n"
			+ "from information_schema.tables t\n"
			+ "         inner join information_schema.columns c on c.table_name = t.table_name and c.table_schema = t.table_schema\n"
			+ "         left join information_schema.KEY_COLUMN_USAGE k2 on t.table_name  = k2.table_name and k2.constraint_name not like '%pk%'\n"
			+ "where c.column_name ilike '%KEYWORD%'\n"
			+ "and t.table_schema in ($1)\n"
			+ "group by 1;\n"
			+ "\n"
			+ "-- generate mapping for keywork2 --\n"
			+ "\n"
			+ "insert into mapeamento.indisponibilidade (tabela, coluna , select_atualizado, fks_da_tabela)\n"
			+ "select distinct\n"
			+ "               t.table_name as tabela\n"
			+ "              ,string_agg(c.column_name, Chr(13)) as coluna\n"
			+ "              ,max(concat('SELECT * FROM '||$1||'.'||t.table_name||' ORDER BY 1 DESC')) as select_atualizado\n"
			+ "              ,string_agg(concat('LEFT JOIN '||k2.column_name|| ' ON ' || k2.column_name|| ' = ' ||'id'), Chr(13) ) as fks_da_tabela\n"
			+ "from information_schema.tables t\n"
			+ "         inner join information_schema.columns c on c.table_name = t.table_name and c.table_schema = t.table_schema\n"
			+ "         left join information_schema.KEY_COLUMN_USAGE k2 on t.table_name  = k2.table_name and k2.constraint_name not like '%pk%'\n"
			+ "where c.column_name ilike '%KEYWORD%'\n"
			+ "and t.table_schema in ($1)\n"
			+ "group by 1;\n"
			+ "\n"
			+ "\n"
			+ "-- generate mapping for keywork3 --\n"
			+ "\n"
			+ "insert into mapeamento.indpessoal (tabela, coluna , select_atualizado, fks_da_tabela)\n"
			+ "select distinct\n"
			+ "               t.table_name as tabela\n"
			+ "              ,string_agg(c.column_name, Chr(13)) as coluna\n"
			+ "              ,max(concat('SELECT * FROM '||$1||'.'||t.table_name||' ORDER BY 1 DESC')) as select_atualizado\n"
			+ "              ,string_agg(concat('LEFT JOIN '||k2.column_name|| ' ON ' || k2.column_name|| ' = ' ||'id'), Chr(13) ) as fks_da_tabela\n"
			+ "from information_schema.tables t\n"
			+ "         inner join information_schema.columns c on c.table_name = t.table_name and c.table_schema = t.table_schema\n"
			+ "         left join information_schema.KEY_COLUMN_USAGE k2 on t.table_name  = k2.table_name and k2.constraint_name not like '%pk%'\n"
			+ "where (c.column_name ilike '%KEYWORD%' or  c.column_name ilike '%KEYWORD%')\n"
			+ "and t.table_schema in ($1)\n"
			+ "group by 1;\n"
			+ "\n"
			+ "-- generate mapping of primary keys and creates your pk --\n"
			+ "\n"
			+ "insert into mapeamento.ddl(ddl)\n"
			+ "select string_agg(ddl,Chr(13)) as ddl\n"
			+ "from (\n"
			+ "         select distinct\n"
			+ "                        t.table_name as tabela\n"
			+ "                       ,k2.constraint_name\n"
			+ "                       ,CASE WHEN k2.constraint_name IS NOT NULL THEN concat('ALTER TABLE ',$1,'.',t.table_name,' ADD COLUMN IF NOT EXISTS (YOUR_PRIMARY_KEY_NAME) UUID ',Chr(13),'GENERATED ALWAYS AS (',upper(k2.column_name),'::TEXT,','''',upper(k2.constraint_name),'''',')) STORED;\n"
			+ "CREATE INDEX CONCURRENTLY IF NOT EXISTS IDX_',upper(t.table_name),' ON ',$1,'.',t.table_name,' (YOUR_PRIMARY_KEY_NAME);',Chr(13))::text ELSE NULL END AS ddl\n"
			+ "         from information_schema.tables t\n"
			+ "                  inner join information_schema.columns c on c.table_name = t.table_name and c.table_schema = t.table_schema\n"
			+ "                  left join information_schema.KEY_COLUMN_USAGE k2 on t.table_name  = k2.table_name and k2.constraint_name like '%pk%'\n"
			+ "                  and t.table_schema in ($1)\n"
			+ "         group by 1,2,3\n"
			+ "     )a;\n"
			+ "RETURN;\n"
			+ "END;\n"
			+ "$$ LANGUAGE plpgsql;";

	public static String getFunction() {
		return function;
	}
}
